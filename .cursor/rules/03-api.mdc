---
description: Padroes da camada API - client, modulos e tipos
globs: ["src/api/**"]
alwaysApply: false
---

# API Layer - Padroes CORRETOS

## Client (`api/client.ts`)

- Axios instance com `baseURL` de `VITE_API_URL`
- Request interceptor: `Authorization: Bearer <token>` de localStorage
- Response interceptor: erro tratado com `ERROR_HANDLERS` de `@/lib/errorCodes`, toast.error, redirect/logout
- NUNCA modificar o client sem entender o fluxo de erro global

## Modulos (um arquivo por dominio)

```tsx
import { api } from './client'
import type { X, PaginatedResponse } from '@/types'

export async function listX(params?: ListXParams): Promise<PaginatedResponse<X>> {
  const { data } = await api.get<PaginatedResponse<X>>('/x', { params })
  return data
}

export async function createX(payload: CreateXPayload) {
  const { data } = await api.post<X>('/x', payload)
  return data
}

export async function updateX(id: string, payload: UpdateXPayload) {
  const { data } = await api.patch<X>(`/x/${id}`, payload)
  return data
}

export async function deleteX(id: string) {
  await api.delete(`/x/${id}`)  // 204 sem body — NUNCA retornar data
}
```

## Soft Delete / Restore / Lixeira

```tsx
export async function listDeletedX(params: { page: number; limit: number }): Promise<PaginatedResponse<X>> {
  const { data } = await api.get<PaginatedResponse<X>>('/x/deleted', { params })
  return data
}

export async function restoreX(id: string) {
  const { data } = await api.patch<X>(`/x/${id}/restore`)
  return data
}
```

## Convencoes

- Naming: `listX`, `getX`, `createX`, `updateX`, `deleteX`, `restoreX`, `listDeletedX`, verbos especificos (`suspendUser`, `restoreUser`)
- Payload types: `interface` no mesmo arquivo (`CreateXPayload`, `UpdateXPayload`, `ListXParams`)
- Response types: importar de `@/types` (`X`, `PaginatedResponse<X>`)
- DELETE retorna void (backend envia 204) — NUNCA `const { data } = await api.delete(...)`
- PATCH/POST retorna o objeto atualizado
- NUNCA try/catch nos modulos (interceptor global cuida)

## Tratamento de erro 409 (deactivation blocked)

Nas pages, quando o delete retorna 409, capturar `details` no `onError`:
```tsx
onError: (error: unknown) => {
  const axiosError = error as { response?: { status?: number; data?: { details?: DeactivationErrorDetails } } }
  if (axiosError.response?.status === 409 && axiosError.response.data?.details) {
    setBlockedInfo({ ... })
  }
}
```
NUNCA usar `error: any` — sempre `error: unknown` com type assertion.

## Backend Reference

Os endpoints seguem o padrao REST do backend (`c:\Users\eduar\Documents\claveBack`):
- POST = criar (201), GET = listar/buscar (200), PATCH = atualizar (200), DELETE = soft delete (204)
- Paginacao: `?page=1&limit=10` retorna `{ data, pagination: { page, limit, total, totalPages } }`
- Consultar rules do backend (`.cursor/rules/03-infrastructure.md`) para detalhes de rotas
